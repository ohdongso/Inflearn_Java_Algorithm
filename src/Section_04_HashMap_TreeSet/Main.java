package Section_04_HashMap_TreeSet;

import java.util.Scanner;

public class Main {
	/*
	    
		1, m번의 수학성적이 주어지면 멘토와 멘티가 되는 짝을 만들 수 있는 경우가 총 몇 가지 인지 출력하는 프로그램을 작성하세요.
		2, 학생수 == n, 시험수 == m, m*n 2차원 배열을 입력받는다.
		3, 비교방법
			1번학생
				1번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			1번학생 
				2번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			1번학생
				3번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			1번학생
				4번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			==> cnt가 3이면 1번학생은 1번학생보다 모든 수학시험에서 등수가 높기 때문에 (1번학생,1번학생)은 멘토, 멘티가 될수 있으므로 answer++ 된다.
			
			2번학생 
				1번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			2번학생 
				2번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			2번학생
				3번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			2번학생
				4번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			==> cnt가 3이면 1번학생은 1번학생보다 모든 수학시험에서 등수가 높기 때문에 (1번학생,1번학생)은 멘토, 멘티가 될수 있으므로 answer++ 된다.
			
			3번학생 
				1번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			3번학생 
				2번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			3번학생
				3번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			3번학생
				4번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			==> cnt가 3이면 1번학생은 1번학생보다 모든 수학시험에서 등수가 높기 때문에 (1번학생,1번학생)은 멘토, 멘티가 될수 있으므로 answer++ 된다.
			
			4번학생 
				1번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			4번학생 
				2번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			4번학생
				3번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			4번학생
				4번학생, (1행,2행,3행) ~ (1열~4열) ==> 비교대상이 되는 학생보다 등수가 낮으면(수학점수가 높으면) cnt++;
			==> cnt가 3이면 1번학생은 1번학생보다 모든 수학시험에서 등수가 높기 때문에 (1번학생,1번학생)은 멘토, 멘티가 될수 있으므로 answer++ 된다.	
	*/
	
	public int solution(int n, int m, int[][] arr) {
		int answer = 0;
		
		// i, j를 인덱스로 사용하는게 아니라, 학생번호로 사용하기 때문에 0부터 시작안해도 된다.
		for(int i = 1; i <= n; i++) { // 1~4(4번), "멘토"가 될 학생
			for(int j = 1; j <= n; j++) { // 1~4(4번), 멘토가 될 학생과 비교될 "멘티"가 될 학생
				int cnt = 0; // i번호 학생이 j번호에 해당하는 학생보다 수학시험점수가 높으면 +1 되는 변수
				for(int k = 0; k < m; k++) { // 0~2, 총 수학시험 횟수, 행
					int pi = 0, pj = 0; // pi == 비교기준학생번호(멘토), 비교될학생번호(멘티)
					for(int s = 0; s < n; s++) { // 0~3, 각 학생 번호, 열
						if(arr[k][s] == i) pi=s; // i에 해당하는 학생번호 index가 저장된다.
						if(arr[k][s] == j) pj=s; // j에 해당하는 학생번호 index가 저장된다.
						
						/*
						 3 4 1 2 ==> arr[0][0]은 3번학생이 첫번째 시험에서 수학점수를 1등 한것이다.
				   		 4 3 2 1
				         3 1 4 2
						 
						 (1) 멘토(1번학생), 멘티(1번학생)
						 첫 번째 행에서 학생번호가 1(i)번인 학생의 index를 pi에 저장. ==> 2
						 	첫 번째 행에서 학생번호가 1(j)인 학생의 index를 pj에 저장. ==> 2
						 		한 행을 돌고나면 멘토(i)가 멘티(j)보다 등수가 낮을경우(시험점수가 높아서 등수가 낮은것) cnt++ 해준다. ==> 0
						 두 번째 행에서 학생번호가 1(i)번인 학생의 index를 pi에 저장. ==> 3
						 	두 번째 행에서 학생번호가 1(j)인 학생의 index를 pj에 저장. ==> 3
						 		한 행을 돌고나면 멘토(i)가 멘티(j)보다 등수가 낮을경우(시험점수가 높아서 등수가 낮은것) cnt++ 해준다. ==> 0
						 세 번째 행에서 학생번호가 1(i)번인 학생의 index를 pi에 저장. ==> 1
							세 번째 행에서 학생번호가 1(j)인 학생의 index를 pj에 저장. ==> 1
						 		한 행을 돌고나면 멘토(i)가 멘티(j)보다 등수가 낮을경우(시험점수가 높아서 등수가 낮은것) cnt++ 해준다. ==> 0
						 ==> 12번
						 						 					 										
						 (2) 멘토(1번학생), 멘티(2번학생)
						 첫 번째 행에서 학생번호가 1(i)번인 학생의 index를 pi에 저장. ==> 2
						 	첫 번째 행에서 학생번호가 2(j)인 학생의 index를 pj에 저장. ==> 3
						 		한 행을 돌고나면 멘토(i)가 멘티(j)보다 등수가 낮을경우(시험점수가 높아서 등수가 낮은것) cnt++ 해준다. ==> 1
						 두 번째 행에서 학생번호가 1(i)번인 학생의 index를 pi에 저장. ==> 3
						 	두 번째 행에서 학생번호가 2(j)인 학생의 index를 pj에 저장. ==> 2
						 		한 행을 돌고나면 멘토(i)가 멘티(j)보다 등수가 낮을경우(시험점수가 높아서 등수가 낮은것) cnt++ 해준다. ==> 1
						 세 번째 행에서 학생번호가 1(i)번인 학생의 index를 pi에 저장. ==> 1
							세 번째 행에서 학생번호가 2(j)인 학생의 index를 pj에 저장. ==> 3
						 		한 행을 돌고나면 멘토(i)가 멘티(j)보다 등수가 낮을경우(시험점수가 높아서 등수가 낮은것) cnt++ 해준다. ==> 2
						 ==> 24번
						 					 
						 .... 위 알고리즘이 반복된다.						 	 
						 tip ==> (i,j)가 같으면 (pi,pj)값이 동일하기 때문에 cnt가 증가하는 경우가 없다.		
						 */	
						
//						aaa++; 몇번반복하는지 확인하는 변수 
						
					} // s 반복문 끝.
					
					// 학생의 index번호 낮다는건 수학점수가 높아서 등수가 낮다는 의미다.
					if(pi < pj) {
						cnt++;
					}
					
				} // k 반복문 끝.
				
				// 전체 행을 돌고나서 멘토(i)가 멘티(j)보다 모든 시험에서 등수가 높으면(cnt == m), 
				// i와j는 멘토 멘티가 될수 있다. answer++;
				if(cnt == m) {
					answer++;
				}
			}
		}
		
		return answer;
	}
	public int solution(String s, char t) {
		int answer = 1;

		return answer;
	}
	
	public static void main(String[] args) {
		Main T = new Main();
		Scanner kb = new Scanner(System.in);
		int n = kb.nextInt(); // 학생 수 ==> 4
		int m = kb.nextInt(); // 시험 수 ==> 3
		int[][] arr = new int[m][n];
		
		// 2차원배열에 해당하는 행열값을 공백을 기준으로 한번에 입력받을수 있다.
		for(int i = 0; i < m; i++) { // 0~2
			for(int j = 0; j < n; j++) { // 0~3
				arr[i][j] = kb.nextInt();
			}
		}
		/* 
		   (입력배열) 
		   1 2 3 4 ▶ 등수
		 1 * * * * ▶ 학생번호
		 2 * * * *
		 3 * * * *
		 ▼
		 테스트 번호
		 
		   1 2 3 4 ▶ 등수
		 1 3 4 1 2 ▶ 학생번호
		 2 4 3 2 1
		 3 3 1 4 2
		 ▼
		 테스트 번호
		   
		   (실제저장된 값, 3*4)
		 X X X X X ▶ 등수
		 X 3 4 1 2 ▶ 학생번호
		 X 4 3 2 1
		 X 3 1 4 2
		 ▼
		 테스트 번호
		 */
		
		System.out.print(T.solution(n, m, arr));
	}
}