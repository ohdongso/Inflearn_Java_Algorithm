-피보나치수열: 앞의 2개의 수를 합하여 다음 숫자가 되는 수열이다.
-소수: 1보다 큰 자연수 중 1과 자기 자기 자신만을 약수로 가지는 수.
-에라토스테네스 체: 소수를 찾는 빠르고 쉬운 방법이다.(1~N까지 숫자에서 소수를 구하는 방법 중 가장 빠르다.)
 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다.
 2는 소수이므로 오른쪽에서 2를 쓴다.
 자기 자신을 제외한 2의 배수를 모드 지운다.
 남아있는 수 가 운데 3은 소수이므로 오른쪽에 3을 쓴다.
 자기 자신을 제외한 3의 배수를 모두 지운다.
 남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다.
 자기 자신을 제외한 5의 배수를 모두 지운다.
 남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다.
 자기자신을 제외한 7의 배수를 모두 지운다.
 위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.
 tip 120의 숫자의 경우 11^2 ? 120이므로 11보다 작은 수의 배소들만 지워도 충분하다.(제곱을 기준으로 어디까지 비교 할건지 고민할수 있다.)
 즉 120보다 작거나 같은 수 가운데 2, 3, 5, 7의 배소를 지우고 남는 수는 모두 소수이다.
-숫자를 뒤집는 알고리즘
 "tmp"는 입력 받은 각각의 자연수를 의미, "res"는 "tmp"를 뒤집은 결과가 담길 변수, "t"는 "tmp"를 % 10해서 나온 일의자리를 의미한다. 
 int tmp = 1230
 t   = tmp % 10 ==> tmp의 일의 자리를 구해준다.
 res = res * 10 + t ==> res에 한자리씩 뒤집은 숫자를 누적해준다.(신기한게 숫자가 누적되면서 리버스된다.)
 tmp = tmp / 10 ==> tmp는 한자리가 리버스 됐기 때문에, 한 자리를 줄여준다.
   1번째 수행, 0 = 0 * 10 + "0"
   1번째 수행, 123"0" / 10 == 123(tmp)
   2번째 수행, 3 = 0 * 10 + "3"
   2번째 수행, 12"3" / 10 == 12(tmp)
   3번째 수행, 32 = 3 * 10 + "2"
   3번째 수행, 1"2" / 10 == 1(tmp)
   4번째 수행, 321 = 32 * 10 + "1"
   3번째 수행, "1" / 10 == 0(tmp) ==> tmp가 0이 되면 종료된다.
-  
 
 